<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Machine Learning Career Roadmap - Interactive 3D Graph</title>
    <link href="https://fonts.googleapis.com/css2?family=Poppins:wght@300;400;500;600;700&display=swap" rel="stylesheet">
    <script src="https://cdn.jsdelivr.net/npm/three@0.152.2/build/three.min.js" defer></script>
    <script src="https://cdn.jsdelivr.net/npm/3d-force-graph@1.77.0/dist/3d-force-graph.min.js" defer></script>
    <link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css" rel="stylesheet">

    <style>
        :root {
            --font-primary: 'Poppins', sans-serif;
            --transition-speed: 0.3s ease-in-out;
            --border-radius-main: 16px;
            --border-radius-small: 8px;
            --bg-light: #e9eef2; --bg-glass-light: rgba(255, 255, 255, 0.7); --border-glass-light: rgba(220, 220, 220, 0.85);
            --text-primary-light: #2c3e50; --text-secondary-light: #566573;
            --accent-primary-light: #2980b9; --accent-secondary-light: #27ae60; --shadow-light: 0 6px 24px 0 rgba(0, 0, 0, 0.08);
            --bg-dark: #1f2227; --bg-glass-dark: rgba(40, 43, 48, 0.7); --border-glass-dark: rgba(55, 58, 63, 0.85);
            --text-primary-dark: #ecf0f1; --text-secondary-dark: #aab8c2;
            --accent-primary-dark: #3498db; --accent-secondary-dark: #2ecc71; --shadow-dark: 0 8px 32px 0 rgba(0, 0, 0, 0.25);
        }
        *, *::before, *::after { box-sizing: border-box; margin: 0; padding: 0; }
        html { background-color: var(--bg-current); color: var(--text-primary-current); transition: background-color var(--transition-speed), color var(--transition-speed); }
        body { font-family: var(--font-primary); line-height: 1.6; overflow-x: hidden; min-height: 100vh; color: inherit; background-color: inherit; }
        html.dark-mode {
            --bg-current: var(--bg-dark); --bg-glass-current: var(--bg-glass-dark); --border-glass-current: var(--border-glass-dark);
            --text-primary-current: var(--text-primary-dark); --text-secondary-current: var(--text-secondary-dark);
            --accent-primary-current: var(--accent-primary-dark); --accent-secondary-current: var(--accent-secondary-dark);
            --shadow-current: var(--shadow-dark);
        }
        html:not(.dark-mode) {
            --bg-current: var(--bg-light); --bg-glass-current: var(--bg-glass-light); --border-glass-current: var(--border-glass-light);
            --text-primary-current: var(--text-primary-light); --text-secondary-current: var(--text-secondary-light);
            --accent-primary-current: var(--accent-primary-light); --accent-secondary-current: var(--accent-secondary-light);
            --shadow-current: var(--shadow-light);
        }
        .page-wrapper { max-width: 1600px; margin: 0 auto; padding: 20px; }
        .page-header { display: flex; justify-content: space-between; align-items: center; flex-wrap: wrap; padding: 15px 0; margin-bottom: 20px; gap: 20px; }
        .page-title { font-size: 2.2em; font-weight: 700; color: var(--accent-primary-current); letter-spacing: -0.5px; margin-right: auto; }
        .header-controls { display: flex; align-items: center; gap: 20px; }
        .dark-mode-toggle { display: flex; align-items: center; cursor: pointer; }
        .dark-mode-toggle input[type="checkbox"] { display: none; }
        .toggle-slider { width: 50px; height: 26px; background-color: #bdc3c7; border-radius: 26px; position: relative; transition: background-color var(--transition-speed); }
        .toggle-slider::before { content: ''; position: absolute; width: 22px; height: 22px; border-radius: 50%; background-color: white; top: 2px; left: 2px; transition: transform var(--transition-speed); box-shadow: 0 2px 4px rgba(0,0,0,0.2); }
        .dark-mode-toggle input:checked + .toggle-slider { background-color: var(--accent-primary-current); }
        .dark-mode-toggle input:checked + .toggle-slider::before { transform: translateX(24px); }
        .toggle-icon { margin-left: 10px; font-size: 1.2em; color: var(--text-secondary-current); }
        html.dark-mode .toggle-icon { color: var(--accent-primary-current); }

        .content-section { background: var(--bg-glass-current); border: 1px solid var(--border-glass-current); border-radius: var(--border-radius-main); padding: 25px; margin-bottom: 30px; box-shadow: var(--shadow-current); backdrop-filter: blur(12px); -webkit-backdrop-filter: blur(12px); }
        .content-section h3 { font-size: 1.5em; font-weight: 600; color: var(--accent-primary-current); margin-bottom: 20px; padding-bottom: 10px; border-bottom: 2px solid var(--accent-primary-current); }
        .content-section p, .content-section li { color: var(--text-secondary-current); font-size: 0.95em; margin-bottom: 10px; }
        .content-section strong { color: var(--text-primary-current); font-weight: 600; }
        #visNetwork { height: 80vh; width: 100%; border-radius: var(--border-radius-small); cursor: default; border: 1px solid var(--border-glass-current); position: relative; overflow: hidden; }
        .legend ul { list-style: none; padding: 0; display: grid; grid-template-columns: repeat(auto-fit, minmax(230px, 1fr)); gap: 8px; }
        .legend li { color: var(--text-secondary-current); padding: 5px 0; font-size: 0.85em; }
        .legend-color-indicator { display: inline-block; width: 10px; height: 10px; border-radius: 50%; margin-right: 6px; vertical-align: middle; border: 1px solid rgba(120,120,120,0.3); }
        .legend-text { vertical-align: middle; }
        .accordion-item { margin-bottom: 15px; border-radius: var(--border-radius-small); overflow: hidden; border: 1px solid var(--border-glass-current); }
        .accordion-header { background-color: rgba(0,0,0,0.02); padding: 15px 20px; cursor: pointer; display: flex; justify-content: space-between; align-items: center; }
        html.dark-mode .accordion-header { background-color: rgba(255,255,255,0.03); }
        .accordion-header:hover { background-color: rgba(0,0,0,0.04); }
        html.dark-mode .accordion-header:hover { background-color: rgba(255,255,255,0.06); }
        .accordion-header strong { font-size: 1.1em; color: var(--text-primary-current); }
        .accordion-icon { font-size: 1em; color: var(--accent-primary-current); transition: transform var(--transition-speed); }
        .accordion-item.active .accordion-icon { transform: rotate(45deg); }
        .accordion-content { max-height: 0; overflow: false; padding: 0 20px; background-color: transparent; transition: max-height 0.5s ease-out, padding var(--transition-speed); }
        .accordion-item.active .accordion-content { max-height: 1500px; padding: 20px; }
        .accordion-content ul { list-style-position: inside; padding-left: 5px; }
        .accordion-content ul li { margin-bottom: 8px; }
        .loading-message { position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); font-size: 1.2em; color: var(--text-secondary-current); text-align: center; padding: 20px; }
        @media (max-width: 768px) {
            .page-title { font-size: 1.8em; margin-bottom: 10px; width:100%; text-align:center; }
            .header-controls { width: 100%; justify-content: center; }
            .content-section { padding: 20px; } .legend ul { grid-template-columns: 1fr; } #visNetwork { height: 65vh; }
            .accordion-header strong { font-size: 1em; }
        }
         @media (max-width: 480px) {
            #visNetwork { height: 60vh; }
        }
    </style>
</head>
<body>
    <div class="page-wrapper">
        <header class="page-header">
            <h1 class="page-title">Machine Learning Roadmap (3D Interactive)</h1>
            <div class="header-controls">
                <label class="dark-mode-toggle" for="darkModeToggle" aria-label="Toggle dark mode">
                    <input type="checkbox" id="darkModeToggle">
                    <span class="toggle-slider"></span>
                    <i class="fas fa-moon toggle-icon" id="modeIcon"></i>
                </label>
            </div>
        </header>

        <section class="content-section" id="roadmap-visualization">
            <h3>Career Visualization (3D) - Click nodes to explore!</h3>
            <div id="visNetwork">
                <div class="loading-message">Loading 3D Graph Libraries...</div>
            </div>
        </section>

        <section class="content-section" id="legend-section">
            <h3>Legend</h3>
            <p>Node colors and shapes represent different categories in Machine Learning:</p>
             <ul class="legend">
                <li><span class="legend-color-indicator" style="background-color: #A0D2DB;"></span><span class="legend-text">Foundations</span></li>
                <li><span class="legend-color-indicator" style="background-color: #F7C8E0;"></span><span class="legend-text">Mathematics</span></li>
                <li><span class="legend-color-indicator" style="background-color: #BEE1E6;"></span><span class="legend-text">Data Science Core</span></li>
                <li><span class="legend-color-indicator" style="background-color: #A9DFBF;"></span><span class="legend-text">Core ML Models</span></li>
                <li><span class="legend-color-indicator" style="background-color: #D4A0F9;"></span><span class="legend-text">Deep Learning</span></li>
                <li><span class="legend-color-indicator" style="background-color: #FFB347;"></span><span class="legend-text">NLP</span></li>
                <li><span class="legend-color-indicator" style="background-color: #87CEEB;"></span><span class="legend-text">Computer Vision</span></li>
                <li><span class="legend-color-indicator" style="background-color: #FFDAB9;"></span><span class="legend-text">Reinforcement Learning</span></li>
                <li><span class="legend-color-indicator" style="background-color: #FEC89A;"></span><span class="legend-text">MLOps</span></li>
                <li><span class="legend-color-indicator" style="background-color: #B2BABB;"></span><span class="legend-text">Tools & Libraries</span></li>
                <li><span class="legend-color-indicator" style="background-color: #E0BBE4;"></span><span class="legend-text">Courses/Certs</span></li>
                <li><span class="legend-color-indicator" style="background-color: #C7CEEA;"></span><span class="legend-text">General Concepts</span></li>
            </ul>
        </section>

        <section class="content-section" id="learning-path">
            <h3>Recommended Learning Path</h3>
            <div class="accordion">
                <div class="accordion-item">
                    <div class="accordion-header"><strong>Phase 1: Foundational Knowledge (3-9 months)</strong><i class="fas fa-plus accordion-icon"></i></div>
                    <div class="accordion-content">
                        <ul>
                            <li><strong>Mathematics:</strong> Linear Algebra (Vectors, Matrices, Eigenvalues/vectors), Calculus (Derivatives, Gradients, Integrals), Probability & Statistics (Distributions, Hypothesis Testing, Bayes' Theorem, Regression basics).</li>
                            <li><strong>Programming:</strong> Python (Core syntax, data structures, functions, classes, OOP basics), NumPy (Numerical computation), Pandas (Data manipulation).</li>
                            <li><strong>Computer Science Basics:</strong> Data Structures & Algorithms, Version Control (Git/GitHub).</li>
                            <li><strong>Intro to Data Visualization:</strong> Matplotlib, Seaborn for basic plotting.</li>
                        </ul>
                    </div>
                </div>
                <div class="accordion-item">
                    <div class="accordion-header"><strong>Phase 2: Core Machine Learning (6-12 months)</strong><i class="fas fa-plus accordion-icon"></i></div>
                    <div class="accordion-content">
                        <ul>
                            <li><strong>Machine Learning Concepts:</strong> Supervised Learning (Regression, Classification), Unsupervised Learning (Clustering, Dimensionality Reduction), Model Evaluation Metrics (Accuracy, Precision, Recall, F1, ROC/AUC, MSE, MAE), Bias-Variance Tradeoff, Overfitting/Underfitting, Cross-Validation.</li>
                            <li><strong>Data Preprocessing & Feature Engineering:</strong> Handling Missing Data, Outlier Detection, Data Scaling & Normalization, Categorical Encoding, Feature Selection & Extraction (PCA, t-SNE), Exploratory Data Analysis (EDA).</li>
                            <li><strong>Traditional ML Algorithms:</strong> Linear/Logistic Regression, Decision Trees, Random Forests, Gradient Boosting Machines (XGBoost, LightGBM), Support Vector Machines (SVM), K-Means Clustering, K-Nearest Neighbors (KNN).</li>
                            <li><strong>Key Libraries:</strong> Scikit-learn.</li>
                            <li><strong>Practical Projects:</strong> Start working on small datasets (e.g., from Kaggle, UCI ML Repository).</li>
                        </ul>
                    </div>
                </div>
                <div class="accordion-item">
                    <div class="accordion-header"><strong>Phase 3: Deep Learning & Specialization (9-18+ months)</strong><i class="fas fa-plus accordion-icon"></i></div>
                    <div class="accordion-content">
                        <ul>
                            <li><strong>Deep Learning Fundamentals:</strong> Neural Networks Basics (Neurons, Layers, Activation Functions, Backpropagation), Convolutional Neural Networks (CNNs), Recurrent Neural Networks (RNNs, LSTMs, GRUs), Optimizers, Loss Functions, Regularization (Dropout), Transfer Learning.</li>
                            <li><strong>Deep Learning Frameworks:</strong> TensorFlow (with Keras), PyTorch.</li>
                            <li><strong>Specializations:</strong> Natural Language Processing (NLP - Text Preprocessing, Word Embeddings, Transformers like BERT/GPT), Computer Vision (CV - Image Classification, Object Detection, Segmentation), Reinforcement Learning (RL).</li>
                            <li><strong>MLOps (Machine Learning Operations):</strong> Model Deployment (Flask/Django APIs, Docker, Kubernetes), Model Monitoring, Versioning (DVC, MLflow), CI/CD, Cloud ML Platforms (AWS SageMaker, Google AI Platform, Azure ML).</li>
                        </ul>
                    </div>
                </div>
                 <div class="accordion-item">
                    <div class="accordion-header"><strong>Phase 4: Advanced Practice & Research (Ongoing)</strong><i class="fas fa-plus accordion-icon"></i></div>
                    <div class="accordion-content">
                        <ul>
                            <li><strong>Advanced Topics:</strong> Generative AI, Explainable AI (XAI), Federated Learning, Quantum ML, Graph Neural Networks.</li>
                            <li><strong>Research & Innovation:</strong> Reading and implementing research papers, contributing to open source.</li>
                            <li><strong>Large-Scale Projects & Domain Expertise.</strong></li>
                            <li><strong>Ethics in AI:</strong> Understanding bias, fairness, and societal impact.</li>
                            <li><span class="soft-skill-text"><strong>Mentorship & Leadership.</strong></span></li>
                        </ul>
                    </div>
                </div>
            </div>
        </section>

        <section class="content-section" id="certifications-courses">
            <h3>Notable Courses & Certifications</h3>
            <p>Focus on hands-on projects and understanding; courses supplement this.</p>
            <ul>
                <li><strong>Foundational:</strong> Andrew Ng's Machine Learning Specialization (Coursera), DeepLearning.AI TensorFlow Developer Professional Certificate, Mathematics for Machine Learning Specialization (Coursera), Fast.ai Courses.</li>
                <li><strong>Platform-Specific:</strong> Google Cloud Professional Machine Learning Engineer, AWS Certified Machine Learning - Specialty, Microsoft Certified: Azure AI Engineer/Data Scientist Associate.</li>
                <li><strong>Specialized:</strong> Stanford CS224N (NLP), Stanford CS231n (CV), DeepMind x UCL Reinforcement Learning Lectures.</li>
            </ul>
        </section>

        <section class="content-section" id="soft-skills">
            <h3>Crucial Soft Skills for ML</h3>
            <ul>
                <li><span class="soft-skill-text"><strong>Problem Solving & Analytical Thinking</strong></span></li>
                <li><span class="soft-skill-text"><strong>Statistical Intuition & Data Sense</strong></span></li>
                <li><span class="soft-skill-text"><strong>Communication (Written & Verbal)</strong></span></li>
                <li><span class="soft-skill-text"><strong>Continuous Learning & Curiosity</strong></span></li>
                <li><span class="soft-skill-text"><strong>Attention to Detail & Rigor</strong></span></li>
                <li><span class="soft-skill-text"><strong>Experimentation Mindset</strong></span></li>
                <li><span class="soft-skill-text"><strong>Business Acumen</strong></span></li>
                <li><span class="soft-skill-text"><strong>Ethical Awareness</strong></span></li>
            </ul>
        </section>

        <section class="content-section" id="learning-resources">
            <h3>Recommended Learning Resources</h3>
            <ul>
                <li><span class="resource-text"><strong>Platforms & Competitions:</strong> Kaggle, Zindi.</span></li>
                <li><span class="resource-text"><strong>Online Courses:</strong> Coursera, edX, Udacity, DataCamp, Fast.ai, DeepLearning.AI.</span></li>
                <li><span class="resource-text"><strong>Books:</strong> "Hands-On Machine Learning" (Géron), "Pattern Recognition and Machine Learning" (Bishop), "Deep Learning" (Goodfellow et al.).</span></li>
                <li><span class="resource-text"><strong>Documentation:</strong> Scikit-learn, TensorFlow, PyTorch, Pandas, NumPy.</span></li>
                <li><span class="resource-text"><strong>Research Papers:</strong> ArXiv (cs.LG, cs.AI, stat.ML), PapersWithCode.</span></li>
                <li><span class="resource-text"><strong>Blogs & Communities:</strong> Towards Data Science, KDnuggets, Distill.pub, Reddit (r/MachineLearning, r/datascience).</span></li>
            </ul>
        </section>

    </div>

    <script>
        const darkModeToggle = document.getElementById('darkModeToggle');
        const modeIcon = document.getElementById('modeIcon');
        const getCssVar = (name) => getComputedStyle(document.documentElement).getPropertyValue(name).trim();

        function applyTheme() {
            if (darkModeToggle.checked) {
                document.documentElement.classList.add('dark-mode');
                modeIcon.classList.remove('fa-moon'); modeIcon.classList.add('fa-sun');
                localStorage.setItem('theme', 'dark');
            } else {
                document.documentElement.classList.remove('dark-mode');
                modeIcon.classList.remove('fa-sun'); modeIcon.classList.add('fa-moon');
                localStorage.setItem('theme', 'light');
            }
            const graphContainer = document.getElementById('visNetwork');
            if (graphContainer) {
                graphContainer.style.border = `1px solid ${getCssVar('--border-glass-current')}`;
            }
            if(Graph) { 
                Graph.backgroundColor(darkModeToggle.checked ? getCssVar('--bg-dark') : getCssVar('--bg-light'));
                Graph.scene().children.find(c => c instanceof THREE.AmbientLight)?.color.setHex(darkModeToggle.checked ? 0x666666 : 0xaaaaaa);
                Graph.graphData().nodes.forEach(node => {
                    if (node.__threeObj) {
                        const labelSprite = node.__threeObj.children.find(child => child.name === 'labelSprite');
                        if (labelSprite) { 
                            node.__threeObj.remove(labelSprite); 
                            const newLabel = createTextLabel(node.name || node.id, node.color); 
                            const labelOffset = (node.shape === 'cone' ? (node.size * 0.9) : (node.size * 0.6)) + 3;
                            newLabel.position.set(0, labelOffset, 0);
                            node.__threeObj.add(newLabel); 
                        }
                    }
                });
                updateNodeVisuals(); 
            }
        }
        const savedTheme = localStorage.getItem('theme');
        if (savedTheme === 'dark') { darkModeToggle.checked = true; }

        const DEFAULT_NODE_OPACITY = 0.85;
        const SELECTED_NODE_OPACITY = 1.0; 
        const NEIGHBOR_NODE_OPACITY = 0.9; 
        const DIMMED_NODE_OPACITY = 0.08; 
        const DEFAULT_LABEL_OPACITY = 0.7;
        const SELECTED_LABEL_OPACITY = 0.95; 
        const NEIGHBOR_LABEL_OPACITY = 0.85; 
        const DIMMED_LABEL_OPACITY = 0.05;
        const DEFAULT_LINK_OPACITY = 0.15;
        const SELECTED_LINK_OPACITY = 0.7; 
        const DIMMED_LINK_OPACITY = 0.02;

        let Graph; 
        let currentSelectedNodeData = null;
        let highlightedNodesSet = new Set();
        let highlightedLinksSet = new Set();
        let rawData; // Will hold the initial graph data for reference

        document.addEventListener('DOMContentLoaded', () => {
            applyTheme(); 
            darkModeToggle.addEventListener('change', applyTheme);

            const accordions = document.querySelectorAll('.accordion-item');
            accordions.forEach(accordion => {
                const header = accordion.querySelector('.accordion-header');
                header.addEventListener('click', () => {
                    const isActive = accordion.classList.contains('active');
                    accordions.forEach(acc => {
                         if (acc !== accordion) {
                            acc.classList.remove('active');
                            acc.querySelector('.accordion-content').style.maxHeight = 0;
                         }
                    });
                    if (!isActive) {
                        accordion.classList.add('active');
                        const content = accordion.querySelector('.accordion-content');
                        content.style.maxHeight = content.scrollHeight + "px";
                    } else {
                        accordion.classList.remove('active');
                        const content = accordion.querySelector('.accordion-content');
                        content.style.maxHeight = 0;
                    }
                });
            });

            function attemptInitGraph(retries = 5, delay = 300) {
                const graphContainer = document.getElementById('visNetwork');
                const loadingMessageElement = graphContainer.querySelector('.loading-message');
                if (typeof THREE !== 'undefined' && typeof ForceGraph3D !== 'undefined') {
                    if (loadingMessageElement) loadingMessageElement.textContent = "Libraries loaded. Initializing 3D Graph...";
                    initNewGraph();
                } else {
                    if (loadingMessageElement) loadingMessageElement.innerHTML = `Waiting for 3D Graph Libraries... Retrying... (${retries} left)`;
                    if (retries > 0) { setTimeout(() => attemptInitGraph(retries - 1, delay), delay); }
                    else if (loadingMessageElement) {
                        loadingMessageElement.innerHTML = "Error: Failed to load 3D graph components. Refresh or check console.";
                        loadingMessageElement.style.color = "red";
                    }
                }
            }
            attemptInitGraph();
        });


        function initNewGraph() {
            const graphContainer = document.getElementById('visNetwork');
            const loadingMessageElement = graphContainer.querySelector('.loading-message');
            if (loadingMessageElement) loadingMessageElement.style.display = 'none';

            CanvasRenderingContext2D.prototype.roundRect = function (x, y, w, h, r) {
                if (w < 2 * r) r = w / 2; if (h < 2 * r) r = h / 2;
                this.beginPath(); this.moveTo(x + r, y);
                this.arcTo(x + w, y, x + w, y + h, r); this.arcTo(x + w, y + h, x, y + h, r);
                this.arcTo(x, y + h, x, y, r); this.arcTo(x, y, x + w, y, r);
                this.closePath(); return this;
            };
            
            const nodeColors = {
                Foundations: '#A0D2DB', Mathematics: '#F7C8E0', 'Data Science Core': '#BEE1E6',
                'Core ML Models': '#A9DFBF', 'Deep Learning': '#D4A0F9', NLP: '#FFB347',
                'Computer Vision': '#87CEEB', 'Reinforcement Learning': '#FFDAB9', MLOps: '#FEC89A',
                'Tools & Libraries': '#B2BABB', 'Courses/Certs': '#E0BBE4', 'General Concepts': '#C7CEEA',
                Specialization: '#f7a1a0' 
            };

            // Store the initial data in the global rawData variable
            rawData = { 
                nodes: [
                    { id: 'Foundations', name: 'Foundations', group: 'Foundations', color: nodeColors.Foundations, shape: 'capsule', size: 12 },
                    { id: 'Mathematics', name: 'Mathematics', group: 'Mathematics', color: nodeColors.Mathematics, shape: 'sphere', size: 10 },
                    { id: 'Programming', name: 'Programming', group: 'Foundations', color: nodeColors.Foundations, shape: 'capsule', size: 9 },
                    { id: 'CS Basics', name: 'CS Basics', group: 'Foundations', color: nodeColors.Foundations, shape: 'capsule', size: 7 },
                    { id: 'Linear Algebra', name: 'Linear Algebra', group: 'Mathematics', color: nodeColors.Mathematics, shape: 'cube', size: 7 },
                    { id: 'Calculus', name: 'Calculus', group: 'Mathematics', color: nodeColors.Mathematics, shape: 'cube', size: 7 },
                    { id: 'Probability & Stats', name: 'Probability & Stats', group: 'Mathematics', color: nodeColors.Mathematics, shape: 'cube', size: 8 },
                    { id: 'Python', name: 'Python', group: 'Tools & Libraries', color: nodeColors['Tools & Libraries'], shape: 'cylinder', size: 7 },
                    { id: 'NumPy', name: 'NumPy', group: 'Tools & Libraries', color: nodeColors['Tools & Libraries'], shape: 'cylinder', size: 6 },
                    { id: 'Pandas', name: 'Pandas', group: 'Tools & Libraries', color: nodeColors['Tools & Libraries'], shape: 'cylinder', size: 6 },
                    { id: 'Git/GitHub', name: 'Git/GitHub', group: 'Tools & Libraries', color: nodeColors['Tools & Libraries'], shape: 'cylinder', size: 5 },
                    { id: 'Matplotlib/Seaborn', name: 'Matplotlib/Seaborn', group: 'Tools & Libraries', color: nodeColors['Tools & Libraries'], shape: 'cylinder', size: 5 },
                    { id: 'Scikit-learn', name: 'Scikit-learn', group: 'Tools & Libraries', color: nodeColors['Tools & Libraries'], shape: 'cylinder', size: 7 },
                    { id: 'Data Science Core', name: 'Data Science Core', group: 'Data Science Core', color: nodeColors['Data Science Core'], shape: 'sphere', size: 10 },
                    { id: 'Data Collection', name: 'Data Collection', group: 'Data Science Core', color: nodeColors['Data Science Core'], shape: 'cube', size: 6 },
                    { id: 'EDA', name: 'Exploratory Data Analysis (EDA)', group: 'Data Science Core', color: nodeColors['Data Science Core'], shape: 'cube', size: 7 },
                    { id: 'Data Preprocessing', name: 'Data Preprocessing', group: 'Data Science Core', color: nodeColors['Data Science Core'], shape: 'cube', size: 8 },
                    { id: 'Feature Engineering', name: 'Feature Engineering', group: 'Data Science Core', color: nodeColors['Data Science Core'], shape: 'cube', size: 7 },
                    { id: 'Core ML Concepts', name: 'Core ML Concepts', group: 'Core ML Models', color: nodeColors['Core ML Models'], shape: 'sphere', size: 10 },
                    { id: 'Supervised Learning', name: 'Supervised Learning', group: 'Core ML Models', color: nodeColors['Core ML Models'], shape: 'capsule', size: 7 },
                    { id: 'Unsupervised Learning', name: 'Unsupervised Learning', group: 'Core ML Models', color: nodeColors['Core ML Models'], shape: 'capsule', size: 7 },
                    { id: 'Model Evaluation', name: 'Model Evaluation & Validation', group: 'Core ML Models', color: nodeColors['Core ML Models'], shape: 'cone', size: 8 },
                    { id: 'Linear Models', name: 'Linear Models (Regression, Logistic)', group: 'Core ML Models', color: nodeColors['Core ML Models'], shape: 'cube', size: 6 },
                    { id: 'Tree-based Models', name: 'Tree-based Models (DT, RF, GBM)', group: 'Core ML Models', color: nodeColors['Core ML Models'], shape: 'cube', size: 7 },
                    { id: 'SVM', name: 'Support Vector Machines (SVM)', group: 'Core ML Models', color: nodeColors['Core ML Models'], shape: 'cube', size: 6 },
                    { id: 'Clustering Algos', name: 'Clustering (K-Means, Hierarchical)', group: 'Core ML Models', color: nodeColors['Core ML Models'], shape: 'cube', size: 6 },
                    { id: 'Deep Learning', name: 'Deep Learning', group: 'Deep Learning', color: nodeColors['Deep Learning'], shape: 'sphere', size: 10 },
                    { id: 'Neural Networks', name: 'Neural Networks Basics', group: 'Deep Learning', color: nodeColors['Deep Learning'], shape: 'capsule', size: 8 },
                    { id: 'CNNs', name: 'Convolutional Neural Networks (CNNs)', group: 'Deep Learning', color: nodeColors['Deep Learning'], shape: 'cube', size: 7 },
                    { id: 'RNNs/LSTMs', name: 'RNNs/LSTMs/GRUs', group: 'Deep Learning', color: nodeColors['Deep Learning'], shape: 'cube', size: 7 },
                    { id: 'Transformers', name: 'Transformers (BERT, GPT)', group: 'Deep Learning', color: nodeColors['Deep Learning'], shape: 'dodecahedron', size: 7 },
                    { id: 'TensorFlow/Keras', name: 'TensorFlow / Keras', group: 'Tools & Libraries', color: nodeColors['Tools & Libraries'], shape: 'cylinder', size: 7 },
                    { id: 'PyTorch', name: 'PyTorch', group: 'Tools & Libraries', color: nodeColors['Tools & Libraries'], shape: 'cylinder', size: 7 },
                    { id: 'Specializations', name: 'Specializations', group: 'Specialization', color: nodeColors.Specialization, shape: 'sphere', size: 10 },
                    { id: 'NLP', name: 'Natural Language Processing (NLP)', group: 'NLP', color: nodeColors.NLP, shape: 'dodecahedron', size: 9 },
                    { id: 'Computer Vision', name: 'Computer Vision (CV)', group: 'Computer Vision', color: nodeColors['Computer Vision'], shape: 'dodecahedron', size: 9 },
                    { id: 'Reinforcement Learning', name: 'Reinforcement Learning (RL)', group: 'Reinforcement Learning', color: nodeColors['Reinforcement Learning'], shape: 'dodecahedron', size: 9 },
                    { id: 'Time Series', name: 'Time Series Analysis', group: 'Specialization', color: nodeColors.Specialization, shape: 'cone', size: 7 },
                    { id: 'Recommender Systems', name: 'Recommender Systems', group: 'Specialization', color: nodeColors.Specialization, shape: 'cone', size: 7 },
                    { id: 'MLOps', name: 'MLOps', group: 'MLOps', color: nodeColors.MLOps, shape: 'sphere', size: 9 },
                    { id: 'Model Deployment', name: 'Model Deployment', group: 'MLOps', color: nodeColors.MLOps, shape: 'cube', size: 7 },
                    { id: 'Model Monitoring', name: 'Model Monitoring & Versioning', group: 'MLOps', color: nodeColors.MLOps, shape: 'cube', size: 7 },
                    { id: 'Cloud ML Platforms', name: 'Cloud ML Platforms (AWS, GCP, Azure)', group: 'MLOps', color: nodeColors.MLOps, shape: 'capsule', size: 7 },
                    { id: 'Docker/Kubernetes', name: 'Docker/Kubernetes for ML', group: 'Tools & Libraries', color: nodeColors['Tools & Libraries'], shape: 'cylinder', size: 6 },
                    { id: 'Ethics in AI', name: 'Ethics in AI', group: 'General Concepts', color: nodeColors['General Concepts'], shape: 'capsule', size: 7 },
                    { id: 'Courses/Certs', name: 'Courses/Certs', group: 'Courses/Certs', color: nodeColors['Courses/Certs'], shape: 'sphere', size: 8 },
                ],
                links: [ 
                    { source: 'Foundations', target: 'Mathematics' }, { source: 'Foundations', target: 'Programming' }, { source: 'Foundations', target: 'CS Basics' },
                    { source: 'Mathematics', target: 'Linear Algebra' }, { source: 'Mathematics', target: 'Calculus' }, { source: 'Mathematics', target: 'Probability & Stats' },
                    { source: 'Programming', target: 'Python' }, { source: 'Python', target: 'NumPy' }, { source: 'Python', target: 'Pandas' },
                    { source: 'CS Basics', target: 'Git/GitHub' }, { source: 'Foundations', target: 'Data Science Core' },
                    { source: 'Data Science Core', target: 'Data Collection' }, { source: 'Data Science Core', target: 'EDA' }, { source: 'EDA', target: 'Matplotlib/Seaborn' },
                    { source: 'Data Science Core', target: 'Data Preprocessing' }, { source: 'Data Science Core', target: 'Feature Engineering' },
                    { source: 'Pandas', target: 'EDA' }, { source: 'Pandas', target: 'Data Preprocessing' }, { source: 'Data Science Core', target: 'Core ML Concepts' },
                    { source: 'Core ML Concepts', target: 'Supervised Learning' }, { source: 'Core ML Concepts', target: 'Unsupervised Learning' },
                    { source: 'Core ML Concepts', target: 'Model Evaluation' }, { source: 'Core ML Concepts', target: 'Scikit-learn' },
                    { source: 'Supervised Learning', target: 'Linear Models' }, { source: 'Supervised Learning', target: 'Tree-based Models' }, { source: 'Supervised Learning', target: 'SVM' },
                    { source: 'Unsupervised Learning', target: 'Clustering Algos' }, { source: 'Probability & Stats', target: 'Core ML Concepts' }, 
                    { source: 'Linear Algebra', target: 'Core ML Concepts' }, { source: 'Core ML Concepts', target: 'Deep Learning' },
                    { source: 'Deep Learning', target: 'Neural Networks' }, { source: 'Neural Networks', target: 'Calculus' },
                    { source: 'Deep Learning', target: 'CNNs' }, { source: 'Deep Learning', target: 'RNNs/LSTMs' }, { source: 'Deep Learning', target: 'Transformers' },
                    { source: 'Deep Learning', target: 'TensorFlow/Keras' }, { source: 'Deep Learning', target: 'PyTorch' }, { source: 'Deep Learning', target: 'Specializations' },
                    { source: 'Specializations', target: 'NLP' }, { source: 'Specializations', target: 'Computer Vision' }, { source: 'Specializations', target: 'Reinforcement Learning' },
                    { source: 'Specializations', target: 'Time Series' }, { source: 'Specializations', target: 'Recommender Systems' },
                    { source: 'CNNs', target: 'Computer Vision' }, { source: 'RNNs/LSTMs', target: 'NLP' }, { source: 'Transformers', target: 'NLP' },
                    { source: 'Core ML Concepts', target: 'MLOps' }, { source: 'Deep Learning', target: 'MLOps' },
                    { source: 'MLOps', target: 'Model Deployment' }, { source: 'MLOps', target: 'Model Monitoring' }, { source: 'MLOps', target: 'Cloud ML Platforms' },
                    { source: 'Model Deployment', target: 'Docker/Kubernetes' }, { source: 'Foundations', target: 'Ethics in AI' }, 
                    { source: 'Specializations', target: 'Ethics in AI' }, { source: 'Foundations', target: 'Courses/Certs' }, 
                    { source: 'Core ML Concepts', target: 'Courses/Certs' }, { source: 'Deep Learning', target: 'Courses/Certs' }
                ]
            };
            rawData.links.forEach((link, i) => link.id = `link-${i}`);


            function createTextLabel(text, nodeColor) {
                const fontSize = 20; const padding = 10;
                const canvas = document.createElement('canvas'); const ctx = canvas.getContext('2d');
                ctx.font = `600 ${fontSize}px Poppins, Arial, sans-serif`;
                const textMetrics = ctx.measureText(text); const textWidth = textMetrics.width;
                const width = textWidth + padding * 2; const height = fontSize + padding * 1.5;
                canvas.width = width * 2; canvas.height = height * 2; ctx.scale(2, 2);
                ctx.fillStyle = darkModeToggle.checked ? 'rgba(50, 55, 60, 0.7)' : 'rgba(250, 250, 255, 0.7)';
                ctx.roundRect(0, 0, width, height, 8); ctx.fill();
                ctx.fillStyle = darkModeToggle.checked ? '#F0F0F0' : '#222222';
                ctx.textAlign = 'center'; ctx.textBaseline = 'middle';
                ctx.fillText(text, width / 2, height / 2);
                const texture = new THREE.CanvasTexture(canvas); texture.minFilter = THREE.LinearFilter; texture.needsUpdate = true;
                const material = new THREE.SpriteMaterial({ map: texture, depthTest:false, transparent: true, opacity: DEFAULT_LABEL_OPACITY });
                const sprite = new THREE.Sprite(material); sprite.name = 'labelSprite';
                sprite.scale.set(width / 10, height / 10, 1); return sprite;
            }
            
            function createNodeShape(node) {
                let geometry; const size = node.size || 5;
                switch (node.shape) {
                    case 'cube': geometry = new THREE.BoxGeometry(size, size, size); break;
                    case 'cone': geometry = new THREE.ConeGeometry(size / 1.5, size * 1.8, 16); break;
                    case 'cylinder': geometry = new THREE.CylinderGeometry(size*0.7, size*0.7, size*1.5, 16); break;
                    case 'capsule': geometry = new THREE.CapsuleGeometry(size*0.6, size*1.2, 8, 16); break;
                    case 'dodecahedron': geometry = new THREE.DodecahedronGeometry(size*0.8, 0); break;
                    default: geometry = new THREE.SphereGeometry(size, 24, 12); break;
                }
                const material = new THREE.MeshPhongMaterial({ color: node.color || '#cccccc', shininess: 30, transparent: true, opacity: DEFAULT_NODE_OPACITY });
                const mesh = new THREE.Mesh(geometry, material);
                mesh.userData.defaultColor = new THREE.Color(node.color || '#cccccc'); return mesh;
            }

            Graph = ForceGraph3D()
                (graphContainer)
                .graphData(JSON.parse(JSON.stringify(rawData))) 
                .nodeId('id')
                .nodeThreeObject(node => {
                    const obj = createNodeShape(node);
                    const label = createTextLabel(node.name || node.id, node.color);
                    const labelOffset = (node.shape === 'cone' ? (node.size * 0.9) : (node.size * 0.6)) + 3;
                    label.position.set(0, labelOffset, 0);
                    obj.add(label);
                    node.__threeObj = obj; 
                    obj.visible = true; 
                    label.visible = true;
                    return obj;
                })
                .linkWidth(0.7)
                .linkMaterial(link => { 
                    const isMainHighlightedLink = highlightedLinksSet.has(link.id);
                    let opacity;

                    if (currentSelectedNodeData) {
                        if (isMainHighlightedLink) {
                            opacity = SELECTED_LINK_OPACITY;
                        } else {
                            opacity = DIMMED_LINK_OPACITY;
                        }
                    } else {
                        opacity = DEFAULT_LINK_OPACITY;
                    }

                    const color = isMainHighlightedLink ?
                                  (darkModeToggle.checked ? '#ffa500' : '#ff8c00') :
                                  (darkModeToggle.checked ? 0xaaaaaa : 0x666666);

                    const material = new THREE.MeshBasicMaterial({
                        color: color,
                        transparent: true,
                        opacity: opacity
                    });
                    if (link.__threeObj) link.__threeObj.visible = true;
                    return material;
                })
                .linkColor(link => { // This acts as a fallback or can be primary if material isn't used for color
                    if (highlightedLinksSet.has(link.id)) {
                        return darkModeToggle.checked ? '#ffa500' : '#ff8c00';
                    }
                    return darkModeToggle.checked ? 'rgba(180,180,180,0.1)' : 'rgba(100,100,100,0.15)';
                })
                .linkDirectionalParticles(link => highlightedLinksSet.has(link.id) ? 2 : 0) 
                .linkDirectionalParticleWidth(link => highlightedLinksSet.has(link.id) ? 1.5 : 0.5)
                .linkDirectionalParticleColor(link => highlightedLinksSet.has(link.id) ? (darkModeToggle.checked ? '#FFD700' : '#FFA500') : (darkModeToggle.checked ? '#666666' : '#AAAAAA'))
                .backgroundColor(darkModeToggle.checked ? getCssVar('--bg-dark') : getCssVar('--bg-light'))
                .enableNodeDrag(false) 
                .cooldownTicks(300) 
                .onEngineStop(() => { 
                    Graph.graphData().nodes.forEach(node => { node.fx = node.x; node.fy = node.y; node.fz = node.z; });
                    console.log("Engine stopped, nodes fixed.");
                    Graph.cameraPosition({ x: 0, y: 0, z: 350 }, { x: 0, y: 0, z: 0 }, 1200); 
                })
                .onNodeClick(handleNodeClick)
                .onBackgroundClick(resetSelectionAndCamera);

            Graph.scene().add(new THREE.AmbientLight(darkModeToggle.checked ? 0x666666 : 0xaaaaaa, 0.8));
            const directionalLight = new THREE.DirectionalLight(0xffffff, 0.7);
            directionalLight.position.set(60, 100, 150);
            Graph.scene().add(directionalLight);
        }
        
        function resetSelection() {
            if (!Graph) return;
            currentSelectedNodeData = null;
            highlightedNodesSet.clear();
            highlightedLinksSet.clear();
            updateNodeVisuals();
        }

        function resetSelectionAndCamera() {
            resetSelection();
            if (Graph) { 
                 Graph.cameraPosition({ x: 0, y: 0, z: 350 }, { x: 0, y: 0, z: 0 }, 1200);
            }
        }

        function handleNodeClick(node) { 
            if (!Graph) return;

            if (currentSelectedNodeData && currentSelectedNodeData.id === node.id) {
                resetSelection(); 
            } else {
                currentSelectedNodeData = node; 
                highlightedNodesSet.clear();
                highlightedLinksSet.clear();

                highlightedNodesSet.add(node.id); 

                rawData.links.forEach(linkDef => { 
                    const sourceId = typeof linkDef.source === 'string' ? linkDef.source : linkDef.source.id;
                    const targetId = typeof linkDef.target === 'string' ? linkDef.target : linkDef.target.id;
                    
                    if (sourceId === node.id) { 
                        highlightedNodesSet.add(targetId); 
                        highlightedLinksSet.add(linkDef.id); 
                    }
                    else if (targetId === node.id) { 
                         highlightedNodesSet.add(sourceId); 
                         highlightedLinksSet.add(linkDef.id); 
                    }
                });
                updateNodeVisuals();
                focusCameraOnNode(node); 
            }
        }

        function updateNodeVisuals() {
            if (!Graph) return;
            Graph.graphData().nodes.forEach(n => {
                const obj = n.__threeObj;
                if (!obj) return; 
                const material = obj.material;
                const labelSprite = obj.children.find(child => child.name === 'labelSprite');
                
                if (!labelSprite) return; 

                obj.visible = true; 
                labelSprite.visible = true;

                if (currentSelectedNodeData) {
                    if (n.id === currentSelectedNodeData.id) { 
                        material.opacity = SELECTED_NODE_OPACITY;
                        labelSprite.material.opacity = SELECTED_LABEL_OPACITY;
                    } else if (highlightedNodesSet.has(n.id)) { 
                        material.opacity = NEIGHBOR_NODE_OPACITY;
                        labelSprite.material.opacity = NEIGHBOR_LABEL_OPACITY;
                    } else { 
                        material.opacity = DIMMED_NODE_OPACITY;
                        labelSprite.material.opacity = DIMMED_LABEL_OPACITY;
                    }
                } else { 
                    material.opacity = DEFAULT_NODE_OPACITY;
                    labelSprite.material.opacity = DEFAULT_LABEL_OPACITY;
                }
            });
            Graph.linkMaterial(Graph.linkMaterial()); 
            Graph.linkColor(Graph.linkColor());
            Graph.linkDirectionalParticles(Graph.linkDirectionalParticles());
            Graph.linkDirectionalParticleColor(Graph.linkDirectionalParticleColor());
            Graph.linkDirectionalParticleWidth(Graph.linkDirectionalParticleWidth());
        }
        
        function focusCameraOnNode(node) { 
            if (Graph && node && node.__threeObj) {
                let minX = node.x, maxX = node.x, minY = node.y, maxY = node.y, minZ = node.z, maxZ = node.z;
                let count = 1;

                highlightedNodesSet.forEach(nodeId => {
                    if (nodeId === node.id) return; 
                    const neighborNode = Graph.graphData().nodes.find(n => n.id === nodeId);
                    if (neighborNode && typeof neighborNode.x !== 'undefined') { 
                        minX = Math.min(minX, neighborNode.x); maxX = Math.max(maxX, neighborNode.x);
                        minY = Math.min(minY, neighborNode.y); maxY = Math.max(maxY, neighborNode.y);
                        minZ = Math.min(minZ, neighborNode.z); maxZ = Math.max(maxZ, neighborNode.z);
                        count++;
                    }
                });
                
                const center = { x: (minX + maxX) / 2, y: (minY + maxY) / 2, z: (minZ + maxZ) / 2 };
                const range = Math.max(maxX - minX, maxY - minY, maxZ - minZ, node.size * 4 || 20); 
                const distance = range * 1.0 + 80 + (count * 3); 

                const cameraTarget = new THREE.Vector3(center.x, center.y, center.z);
                const cameraPosition = new THREE.Vector3(center.x, center.y + distance * 0.2, center.z + distance);
                Graph.cameraPosition(cameraPosition, cameraTarget, 1000);
            }
        }
    </script>
</body>
</html>
